from flask import Flask, request, jsonify
import base64
from io import BytesIO
import cv2
import numpy as np
import math
import pytesseract  # Don't forget to install pytesseract and Tesseract OCR engine
from collections import defaultdict

app = Flask(__name__)

def decode_image(base64_str):
    """Decode base64 string to OpenCV image"""
    try:
        img_data = base64.b64decode(base64_str)
        img = cv2.imdecode(np.frombuffer(img_data, np.uint8), cv2.IMREAD_COLOR)
        return img
    except Exception as e:
        print(f"Image decoding error: {e}")
        return None

def detect_nodes(img):
    """Detect nodes (black circles) using Hough Circle Transform"""
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    
    # Adjusted Hough Circle parameters for better detection
    circles = cv2.HoughCircles(
        blurred,
        cv2.HOUGH_GRADIENT,
        dp=1,
        minDist=30,  # Increased to reduce duplicate detection
        param1=100,  # Adjusted for better edge detection
        param2=25,   # Lowered to detect more circles
        minRadius=8,
        maxRadius=25
    )
    
    if circles is None:
        return []
    
    # Convert to integers and remove duplicates
    circles = np.uint16(np.around(circles))[0]
    unique_nodes = []
    seen = set()
    for (x, y, r) in circles:
        # More robust duplicate checking
        key = (round(x/10), round(y/10))  # Coarser quantization
        if key not in seen:
            seen.add(key)
            unique_nodes.append((x, y))
    
    return unique_nodes

def detect_edges(img):
    """Detect edges (colored lines) using color thresholding and Canny edge detection"""
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    
    # Improved color range to exclude black (nodes) and include common edge colors
    lower_black = np.array([0, 0, 0])
    upper_black = np.array([180, 255, 50])  # Higher value threshold for black
    black_mask = cv2.inRange(hsv, lower_black, upper_black)
    edge_mask = cv2.bitwise_not(black_mask)  # Edges are non-black
    
    # Clean up mask with morphological operations
    kernel = np.ones((3, 3), np.uint8)
    edge_mask = cv2.morphologyEx(edge_mask, cv2.MORPH_CLOSE, kernel)
    edge_mask = cv2.morphologyEx(edge_mask, cv2.MORPH_OPEN, kernel)
    
    # Find edges with Canny
    edges = cv2.Canny(edge_mask, 50, 150)
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    edge_segments = []
    for contour in contours:
        if len(contour) < 5:  # Skip small contours (noise)
            continue
        # Get bounding rectangle for the contour
        x, y, w, h = cv2.boundingRect(contour)
        edge_segments.append((x, y, x + w, y + h))  # (x1, y1, x2, y2)
    
    return edge_segments

def extract_edge_weights(img, edge_segments):
    """Extract weight values from edge segments using OCR"""
    weights = []
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    for (x1, y1, x2, y2) in edge_segments:
        # Calculate midpoint more accurately
        mid_x = (x1 + x2) // 2
        mid_y = (y1 + y2) // 2
        
        # Define ROI around midpoint (adjust size based on expected text size)
        roi_size = 20  # Larger ROI to ensure capturing the weight
        roi = gray[
            max(0, mid_y - roi_size):min(img.shape[0], mid_y + roi_size),
            max(0, mid_x - roi_size):min(img.shape[1], mid_x + roi_size)
        ]
        
        if roi.size == 0:  # Skip empty ROI
            weights.append(None)
            continue
        
        # Better preprocessing for OCR
        _, thresh = cv2.threshold(roi, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
        thresh = cv2.medianBlur(thresh, 3)  # Reduce noise
        
        # OCR configuration optimized for single digits/numbers
        custom_config = r'--oem 3 --psm 10 -c tessedit_char_whitelist=0123456789'
        text = pytesseract.image_to_string(thresh, config=custom_config).strip()
        
        if text.isdigit():
            weights.append(int(text))
        else:
            weights.append(None)  # Use None instead of fallback to detect failures
    
    return weights

def associate_edges_with_nodes(edges, nodes, threshold=30):
    """Associate edge segments with their connected nodes"""
    node_edges = []
    for (x1, y1, x2, y2) in edges:
        start_node = None
        end_node = None
        min_dist_start = float('inf')
        min_dist_end = float('inf')
        
        for i, (nx, ny) in enumerate(nodes):
            # Calculate distance from node to edge endpoints
            dist_start = math.hypot(nx - x1, ny - y1)
            dist_end = math.hypot(nx - x2, ny - y2)
            
            if dist_start < min_dist_start and dist_start < threshold:
                min_dist_start = dist_start
                start_node = i
            if dist_end < min_dist_end and dist_end < threshold:
                min_dist_end = dist_end
                end_node = i
        
        # Ensure valid and distinct nodes
        if start_node is not None and end_node is not None and start_node != end_node:
            node_edges.append((start_node, end_node))
        else:
            node_edges.append(None)  # Mark invalid associations
    
    return node_edges

def kruskal_mst(edges, num_nodes):
    """Compute MST weight using Kruskal's algorithm"""
    if num_nodes < 2:
        return 0  # No edges needed for single node
    
    parent = list(range(num_nodes))
    
    def find(u):
        while parent[u] != u:
            parent[u] = parent[parent[u]]  # Path compression
            u = parent[u]
        return u
    
    def union(u, v):
        u_root = find(u)
        v_root = find(v)
        if u_root == v_root:
            return False  # Already in the same set
        parent[v_root] = u_root
        return True
    
    # Sort edges by weight (filter out invalid edges)
    valid_edges = [e for e in edges if e[2] is not None]
    edges_sorted = sorted(valid_edges, key=lambda x: x[2])
    
    mst_weight = 0
    edges_used = 0
    
    for u, v, w in edges_sorted:
        if union(u, v):
            mst_weight += w
            edges_used += 1
            if edges_used == num_nodes - 1:
                break  # MST complete
    
    return mst_weight if edges_used == num_nodes - 1 else 0  # Validate MST completeness

def process_graph(image_base64):
    """Process a single graph image and return MST weight"""
    # Decode image
    img = decode_image(image_base64)
    if img is None:
        return 0
    
    # Detect nodes
    nodes = detect_nodes(img)
    if len(nodes) < 2:  # Need at least 2 nodes for edges
        return 0
    num_nodes = len(nodes)
    
    # Detect edges
    edges = detect_edges(img)
    if not edges:
        return 0
    
    # Extract edge weights
    weights = extract_edge_weights(img, edges)
    
    # Associate edges with nodes
    node_edges = associate_edges_with_nodes(edges, nodes)
    
    # Create list of valid (u, v, weight) edges
    graph_edges = []
    for i in range(len(edges)):
        if node_edges[i] is not None and weights[i] is not None:
            u, v = node_edges[i]
            graph_edges.append((u, v, weights[i]))
    
    if not graph_edges:
        return 0
    
    # Compute MST
    mst_weight = kruskal_mst(graph_edges, num_nodes)
    return mst_weight

@app.route('/mst-calculation', methods=['POST'])
def mst_calculation_endpoint():
    try:
        data = request.get_json()
        if not isinstance(data, list) or len(data) != 2:
            return jsonify({"error": "Input must be a list of 2 test cases"}), 400
        
        results = []
        for test_case in data:
            if not isinstance(test_case, dict) or 'image' not in test_case:
                results.append({"value": 0})  # Invalid test case format
                continue
            
            image_base64 = test_case['image']
            mst_value = process_graph(image_base64)
            results.append({"value": mst_value})
        
        return jsonify(results)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)  # Use debug=False in production